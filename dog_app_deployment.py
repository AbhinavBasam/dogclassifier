# -*- coding: utf-8 -*-
"""Dog_App_Deployment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a9DIKNuwU3U_5G-gldiijknpdw8_suSe
"""

import shutil
from google.colab import files
from google.colab import drive
import os

# 1. Mount Drive to find the files
drive.mount('/content/drive')
source_folder = "/content/drive/MyDrive/Dog_Project_Models"

# 2. Check if files exist
if os.path.exists(source_folder):
    print("‚è≥ Zipping your models... (This might take a minute)")

    # 3. Create a ZIP file of the entire folder
    shutil.make_archive("/content/Dog_Models_Backup", 'zip', source_folder)

    # 4. Trigger the Download
    print("‚¨áÔ∏è Download starting! Check your browser's download bar.")
    files.download("/content/Dog_Models_Backup.zip")
else:
    print("‚ö†Ô∏è Error: Could not find the 'Dog_Project_Models' folder in your Drive.")

pip install tensorflow opencv-python matplotlib tensorflow-datasets
python dog_app.py

#unzip ur folder and run it
#change the model folder path


import tensorflow as tf
from tensorflow import keras
import tensorflow_datasets as tfds
import numpy as np
import matplotlib.pyplot as plt
import tkinter as tk
from tkinter import filedialog, Label, Button, Frame
from PIL import Image, ImageTk
import cv2
import os
import shutil
import urllib.request
from datetime import datetime

# ==========================================
# üõë CONFIGURATION
# ==========================================
# 1. Path to your downloaded models
MODEL_FOLDER = r"C:\Users\YourName\Downloads\Dog_Models_Backup"

# 2. Path to store saved images (Change to empty string "" to disable saving)
HISTORY_FOLDER = r"C:\Users\YourName\Pictures\Dog_App_History"
# ==========================================

# --- SETUP ---
if HISTORY_FOLDER and not os.path.exists(HISTORY_FOLDER):
    os.makedirs(HISTORY_FOLDER)

# Download OpenCV Tools
files_needed = {
    "MobileNetSSD_deploy.prototxt.txt": "https://raw.githubusercontent.com/djmv/MobilNet_SSD_opencv/master/MobileNetSSD_deploy.prototxt",
    "MobileNetSSD_deploy.caffemodel": "https://raw.githubusercontent.com/djmv/MobilNet_SSD_opencv/master/MobileNetSSD_deploy.caffemodel"
}
for fname, url in files_needed.items():
    if not os.path.exists(fname):
        try: urllib.request.urlretrieve(url, fname)
        except: pass

try:
    net = cv2.dnn.readNetFromCaffe("MobileNetSSD_deploy.prototxt.txt", "MobileNetSSD_deploy.caffemodel")
except:
    net = None

# Load Models
try:
    models = {
        'resnet50': keras.models.load_model(os.path.join(MODEL_FOLDER, "resnet50_dogs.keras")),
        'efficientnetb0': keras.models.load_model(os.path.join(MODEL_FOLDER, "efficientnetb0_dogs.keras")),
        'mobilenetv2': keras.models.load_model(os.path.join(MODEL_FOLDER, "mobilenetv2_dogs.keras"))
    }
    mlp = keras.models.load_model(os.path.join(MODEL_FOLDER, "mlp_ensemble.keras"))
except Exception as e:
    print(f"Error loading models: {e}")
    exit()

# Breed Info
breed_info = {
    'american_bulldog': {'life': '10-12 yrs', 'traits': 'Confident, Social, Active'},
    'american_pit_bull_terrier': {'life': '8-15 yrs', 'traits': 'Loyal, Courageous, Friendly'},
    'basset_hound': {'life': '12-13 yrs', 'traits': 'Patient, Low-energy, Charming'},
    'beagle': {'life': '10-15 yrs', 'traits': 'Curious, Merry, Friendly'},
    'boxer': {'life': '10-12 yrs', 'traits': 'Bright, Fun-loving, Active'},
    'chihuahua': {'life': '14-16 yrs', 'traits': 'Charming, Graceful, Sassy'},
    'english_cocker_spaniel': {'life': '12-14 yrs', 'traits': 'Merry, Responsive, Gentle'},
    'english_setter': {'life': '12 yrs', 'traits': 'Friendly, Mellow, Merry'},
    'german_shorthaired': {'life': '10-12 yrs', 'traits': 'Friendly, Smart, Willing'},
    'great_pyrenees': {'life': '10-12 yrs', 'traits': 'Smart, Patient, Calm'},
    'havanese': {'life': '14-16 yrs', 'traits': 'Funny, Intelligent, Outgoing'},
    'japanese_chin': {'life': '10-12 yrs', 'traits': 'Charming, Noble, Loving'},
    'keeshond': {'life': '12-15 yrs', 'traits': 'Friendly, Lively, Outgoing'},
    'leonberger': {'life': '7 yrs', 'traits': 'Gentle, Friendly, Playful'},
    'miniature_pinscher': {'life': '12-16 yrs', 'traits': 'Fearless, Spirited, Proud'},
    'newfoundland': {'life': '9-10 yrs', 'traits': 'Sweet, Patient, Devoted'},
    'pomeranian': {'life': '12-16 yrs', 'traits': 'Lively, Bold, Inquisitive'},
    'pug': {'life': '13-15 yrs', 'traits': 'Loving, Charming, Mischievous'},
    'saint_bernard': {'life': '8-10 yrs', 'traits': 'Playful, Charming, Inquisitive'},
    'samoyed': {'life': '12-14 yrs', 'traits': 'Adaptable, Friendly, Gentle'},
    'scottish_terrier': {'life': '12 yrs', 'traits': 'Independent, Confident, Spirited'},
    'shiba_inu': {'life': '13-16 yrs', 'traits': 'Alert, Active, Attentive'},
    'staffordshire_bull_terrier': {'life': '12-14 yrs', 'traits': 'Clever, Brave, Tenacious'},
    'wheaten_terrier': {'life': '12-14 yrs', 'traits': 'Happy, Steady, Confident'},
    'yorkshire_terrier': {'life': '11-15 yrs', 'traits': 'Sprightly, Tomboyish, Loving'}
}

# Fetch Names
cat_breeds = {"Abyssinian","Bengal","Birman","Bombay","British_Shorthair","Egyptian_Mau",
              "Maine_Coon","Persian","Ragdoll","Russian_Blue","Siamese","Sphynx"}
info = tfds.builder("oxford_iiit_pet").info
dog_names = [n for n in info.features["label"].names if n not in cat_breeds]

# --- LOGIC ---
def save_image_securely(img_array, source="cam"):
    """ Saves image to history folder if configured. Delete lines below to disable. """
    if HISTORY_FOLDER:
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"Dog_{source}_{timestamp}.jpg"
        save_path = os.path.join(HISTORY_FOLDER, filename)
        # Convert RGB to BGR for OpenCV saving
        cv2.imwrite(save_path, cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR))
        print(f"üîí Image saved to history: {filename}")

def get_dog_roi(img):
    (h, w) = img.shape[:2]
    if net:
        blob = cv2.dnn.blobFromImage(cv2.resize(img, (300, 300)), 0.007843, (300, 300), 127.5)
        net.setInput(blob)
        detections = net.forward()
        best_conf = 0.0
        dog_box = None
        for i in range(detections.shape[2]):
            conf = detections[0, 0, i, 2]
            if int(detections[0, 0, i, 1]) == 12 and conf > 0.2:
                if conf > best_conf:
                    best_conf = conf
                    box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
                    dog_box = box.astype("int")
        if dog_box is not None:
            (sx, sy, ex, ey) = dog_box
            sx, sy = max(0, sx-20), max(0, sy-20)
            ex, ey = min(w, ex+20), min(h, ey+20)
            return img[sy:ey, sx:ex], True
    return img, False

def process_and_predict(cv2_img, source_type):
    # Convert to RGB
    if len(cv2_img.shape) == 2: cv2_img = cv2.cvtColor(cv2_img, cv2.COLOR_GRAY2RGB)
    elif cv2_img.shape[2] == 4: cv2_img = cv2.cvtColor(cv2_img, cv2.COLOR_BGRA2RGB)
    else: cv2_img = cv2.cvtColor(cv2_img, cv2.COLOR_BGR2RGB)

    roi, cropped = get_dog_roi(cv2_img)

    # 1. Save Original (Privacy Control)
    save_image_securely(cv2_img, source_type)

    if not cropped:
        print("‚ö†Ô∏è No dog detected by Smart Crop.")

    # 2. Predict
    img_r = cv2.resize(roi, (224, 224))
    img_arr = np.expand_dims(img_r, axis=0) / 255.0

    p1 = models['resnet50'].predict(img_arr, verbose=0)
    p2 = models['efficientnetb0'].predict(img_arr, verbose=0)
    p3 = models['mobilenetv2'].predict(img_arr, verbose=0)
    final = mlp.predict(np.concatenate([p1, p2, p3], axis=1), verbose=0)[0]

    # 3. Top 3 Logic
    top_3_indices = np.argsort(final)[-3:][::-1]

    # 4. Display Result
    plt.figure(figsize=(5, 6))
    plt.imshow(roi)
    plt.axis("off")

    top_name = dog_names[top_3_indices[0]]
    top_score = final[top_3_indices[0]] * 100
    info = breed_info.get(top_name, {'life': '?', 'traits': '?'})

    title = f"üèÜ {top_name} ({top_score:.1f}%)\n{info['life']}"
    plt.title(title, color="green", fontsize=12, fontweight='bold')

    # Add text for other 2
    text_str = "Top 3 Predictions:\n"
    for i in top_3_indices:
        text_str += f"‚Ä¢ {dog_names[i]}: {final[i]*100:.1f}%\n"

    plt.xlabel(text_str, fontsize=10)
    plt.show()

# --- GUI ---
class DogApp:
    def __init__(self, root):
        self.root = root
        self.root.title("üê∂ Dog Breed Classifier Pro")
        self.root.geometry("500x400")

        Label(root, text="Dog Breed Classifier", font=("Arial", 20, "bold")).pack(pady=20)

        btn_frame = Frame(root)
        btn_frame.pack(pady=20)

        Button(btn_frame, text="üìÇ Upload Photo", command=self.upload_mode,
               font=("Arial", 12), bg="#e1e1e1", width=15).pack(side="left", padx=10)

        Button(btn_frame, text="üì∑ Open Camera", command=self.camera_mode,
               font=("Arial", 12), bg="#d1e7dd", width=15).pack(side="left", padx=10)

        Label(root, text="Press Spacebar to snap in camera mode", fg="gray").pack(side="bottom", pady=10)

    def upload_mode(self):
        filename = filedialog.askopenfilename()
        if filename:
            img = cv2.imread(filename)
            if img is not None:
                process_and_predict(img, "upload")

    def camera_mode(self):
        self.cam_window = tk.Toplevel(self.root)
        self.cam_window.title("Camera - Press SPACE to Snap")

        self.video_label = Label(self.cam_window)
        self.video_label.pack()

        self.cap = cv2.VideoCapture(0)

        # Bind Spacebar to Snap
        self.cam_window.bind('<space>', lambda e: self.snap())
        self.update_cam()

    def update_cam(self):
        if self.cap and self.cap.isOpened():
            ret, frame = self.cap.read()
            if ret:
                self.last_frame = frame
                # Convert for Tkinter display
                img = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGBA))
                imgtk = ImageTk.PhotoImage(image=img)
                self.video_label.imgtk = imgtk
                self.video_label.configure(image=imgtk)
            self.cam_window.after(10, self.update_cam)

    def snap(self):
        if self.cap:
            process_and_predict(self.last_frame, "camera")
            self.cap.release()
            self.cam_window.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = DogApp(root)
    root.mainloop()